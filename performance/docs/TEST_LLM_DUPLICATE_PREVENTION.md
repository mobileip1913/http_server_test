# LLM 重复调用防护机制测试指南

## 测试目标

验证防重复调用机制是否正常工作，确保：
1. 正常单次调用工作正常
2. 重复调用被正确阻止
3. 锁在完成时正确清除
4. 日志能正确显示阻止信息

## 测试环境准备

### 1. 启动 WebSocket 服务器

```bash
cd ws_server
npm run dev
```

### 2. 启动测试脚本（如果使用）

```bash
cd performance
python websocket_client.py
```

## 测试场景

### 场景 1: 正常单次调用测试

**目的**: 验证正常流程下，单次 LLM 调用能正常工作

**步骤**:
1. 发送一条语音消息（通过 WebSocket 或测试脚本）
2. 观察服务器日志，应该看到：
   - LLM 调用开始
   - LLM 响应流式返回
   - LLM 调用完成
   - **不应该看到** "LLM调用已在进行中" 的日志

**预期结果**: 
- ✅ LLM 正常响应
- ✅ 只调用一次 LLM
- ✅ 没有重复调用警告

### 场景 2: 快速重复调用测试

**目的**: 验证在短时间内多次触发时，重复调用被阻止

**步骤**:
1. 快速连续发送多条语音消息（间隔 < 1秒）
2. 观察服务器日志，应该看到：
   - 第一条消息：正常调用 LLM
   - 后续消息：应该看到类似 "LLM调用已在进行中，忽略重复调用" 的日志

**预期结果**:
- ✅ 第一条消息正常处理
- ✅ 后续消息被阻止，日志显示阻止信息
- ✅ 只有一次 LLM 调用

### 场景 3: 锁清除测试

**目的**: 验证 LLM 完成后锁被正确清除，后续调用可以正常进行

**步骤**:
1. 发送第一条语音消息
2. 等待 LLM 响应完成（`isStop === true`）
3. 立即发送第二条语音消息
4. 观察服务器日志

**预期结果**:
- ✅ 第一条消息正常处理
- ✅ 第一条完成后锁被清除
- ✅ 第二条消息可以正常调用 LLM（不被阻止）

### 场景 4: 错误处理测试

**目的**: 验证 LLM 调用失败时锁被正确清除

**步骤**:
1. 模拟 LLM 调用失败（可以临时断开网络或修改配置）
2. 触发一次 LLM 调用
3. 等待调用失败
4. 再次触发调用

**预期结果**:
- ✅ 第一次调用失败，日志显示错误
- ✅ 锁被清除（错误处理中）
- ✅ 第二次调用可以正常进行（不被阻止）

### 场景 5: 中止测试

**目的**: 验证 LLM 被 abort 时锁被正确清除

**步骤**:
1. 发送语音消息触发 LLM
2. 在 LLM 响应过程中，触发相机事件（会调用 abort）
3. 观察服务器日志

**预期结果**:
- ✅ LLM 被中止
- ✅ 锁被清除（在 abort 处理中）
- ✅ 后续调用可以正常进行

## 关键日志检查点

### 成功阻止重复调用的日志示例：

```
[LLM] LLM调用已在进行中，忽略重复调用。问题：你好啊，我想去故宫
```

或

```
[LLM] LLM调用已在进行中（intentContinue），忽略重复调用
```

### 锁清除的日志（正常情况下不显示，只在调试时）：

锁清除在以下时机发生：
- `llmStreamCallback` 中 `streamText.isStop === true`
- `fcStreamCallBack` 中 `streamText.isStop === true`
- catch 块中（调用失败时）
- abort 后（相机处理等）

## 监控要点

### 1. 日志监控

关注以下日志模式：
- `LLM调用已在进行中` - 表示重复调用被阻止
- `LLM调用失败` - 表示调用出错，锁应该被清除
- 正常的 LLM 响应日志

### 2. 性能监控

- LLM API 调用次数应该等于用户输入次数（正常情况下）
- 如果出现重复调用，LLM API 调用次数会 > 用户输入次数

### 3. 功能验证

- 用户输入应该得到响应（即使有重复调用被阻止）
- 响应时间正常（不应该因为锁机制而变慢）

## 测试脚本示例

如果需要自动化测试，可以使用以下 Python 脚本：

```python
import asyncio
import websockets
import json
import time

async def test_duplicate_prevention():
    uri = "ws://localhost:8081"  # 根据实际配置修改
    async with websockets.connect(uri) as websocket:
        # 发送第一条消息
        print("发送第一条消息...")
        await websocket.send(json.dumps({
            "type": "start_listen"
        }))
        
        # 快速发送第二条消息（模拟重复调用）
        await asyncio.sleep(0.1)  # 很短间隔
        print("快速发送第二条消息（应该被阻止）...")
        await websocket.send(json.dumps({
            "type": "start_listen"
        }))
        
        # 等待响应
        await asyncio.sleep(5)
        print("测试完成")

asyncio.run(test_duplicate_prevention())
```

## 常见问题排查

### 问题 1: 锁没有被清除

**症状**: 第一次调用后，后续所有调用都被阻止

**可能原因**:
- `isStop` 回调没有被触发
- 锁清除逻辑没有执行

**排查方法**:
- 检查日志中是否有 `isStop === true` 的响应
- 检查 `llmStreamCallback` 或 `fcStreamCallBack` 是否被调用

### 问题 2: 锁没有生效

**症状**: 仍然出现多次 LLM 调用

**可能原因**:
- 锁检查时机不对
- 多个不同的调用路径没有都加锁

**排查方法**:
- 检查所有 `llmService.chat()` 调用是否都有锁保护
- 检查锁设置时机是否正确（在 `CoreService.init()` 之后）

### 问题 3: 正常调用被阻止

**症状**: 单次调用也被阻止

**可能原因**:
- 锁在前一次调用完成后没有被清除
- 锁状态异常

**排查方法**:
- 检查前一次调用是否正常完成
- 检查日志确认锁清除逻辑是否执行

## 测试检查清单

- [ ] 正常单次调用工作正常
- [ ] 快速重复调用被正确阻止
- [ ] 调用完成后锁被清除
- [ ] 调用失败时锁被清除
- [ ] 调用被中止时锁被清除
- [ ] 日志正确显示阻止信息
- [ ] 没有误阻止正常调用
- [ ] 性能没有明显下降

## 测试完成后

如果所有测试通过，说明防重复调用机制工作正常。如果发现问题，请检查：
1. 锁的设置和清除时机
2. 所有调用路径是否都加了保护
3. 日志输出是否正常


